<!DOCTYPE html>

<html>
<head>
  <style>
    span {
      background-color: lightgrey;
      margin: 1px;
    }
    span.string {
      background-color: pink;
    }
    span.comment {
      background-color: green;
    }
    span.block {
      background-color: #8ccbde;
    }
    span.function {
      background-color: purple;
      color: white;
    }
    span.package {
      background-color: red;
      color: white;
    }
  </style>
</head>
<body>
  <div id="page"></div>
  <script type="module">

    let code = `
    # A simple Perl script demonstrating various token types

    use strict;          # Load strict mode for better coding practices
    use warnings;        # Enable warnings
    package authlib;
    # Variable declarations
    my $scalar = 42;          # Scalar variable
    my @array = (1, 2, 3);    # Array variable
    my %hash = (              # Hash variable
    key1 => 'value1',
    key2 => 'value2'
    );

    # String concatenation and repetition
    my $name = "Alice";
    my $greeting = "Hello, " . $name . "!" x 2;

    # Arithmetic operations
    my $sum = 5 + 10 - 3 * 2 / 4 % 3;

    # Comparison operators
    if ($scalar == 42 && $name ne "Bob") {
    print "Scalar is 42 and name is not Bob.\\n";
    }

    # Regular expression matching
    if ($name =~ /A/i) {
    print "$name contains an A.\\n";
    }

    # Subroutine definition and call
    sub greet {
    my ($person) = @_;
    print "Greetings, $person!\\n";
    }
    my $x = 1 + 1;
    greet($name);
    1;
    # Ternary operator
    my $status = ($scalar > 40) ? "High" : "Low";

    # File reading with angle brackets
    open my $file, '<', 'example.txt' or die "Cannot open file: $!";
    while (my $line = <$file>) {
    chomp($line); # Remove newline character
    print "Line: $line\\n";
    }
    close $file;

    # Loop through arrays and hashes
    foreach my $item (@array) {
    print "Array item: $item\\n";
    }

    foreach my $key (keys %hash) {
    print "$key => $hash{$key}\\n";
    }

    # Anonymous subroutine and dereferencing
    my $add = sub {
    my ($x, $y) = @_;
    return $x + $y;
    };
    print "Sum: " . $add->(2, 3) . "\\n";

    # Commented-out code and special characters
    # This line won't run: print "Hidden message";

    # Multi-line string using qq
    my $message = qq{
    This is a multi-line string.
    It preserves line breaks and spacing.
    };

    print $message;

    `;

    const variableMatcher = String.raw`([\$@%]?\w+(::\w+)?)`;
    const operators = "(" + ["<=>", "=>", String.raw`\+=`, "-=", "==", "&&", "=~", "=!",
      String.raw`\|\|`,
      "!=", "<=", ">=", "->"].join("|") + ")";

    const spaceMatcher = String.raw`\s+`;

    const matcher = new RegExp(`${variableMatcher}|${operators}|\\n|${spaceMatcher}|.`, "g");

    const matches = code.matchAll(matcher);
    const page = document.getElementById("page");
    const states = {
      STRING: 1,
      STRING_ESCAPE: 2,
      CODE: 3,
      STRING_INTERPOLATED: 4,
      ESCAPE: 5,
      COMMENT: 6,
      PACKAGE: 7,
      BLOCK: 8,
      FUNCTION: 9,
      DECLARATION: 10,
    };
    const stateStack = [];
    let currentState = states.CODE;
    let tokenType = "CODE";
    let noTokenTypeUpdate = false;
    let currentNode = {
      children: [],
      type: "CODE"
    };

    for (let m of matches) {
      const token = m[0];
      switch (currentState) {
        case states.STRING: {
          stringState(token);
          break;
        }
        case states.CODE: {
            codeState(token);
            break;
          }
        case states.COMMENT: {
            commentState(token);
            break;
          }
        case states.BLOCK: {
            blockState(token);
            break;
          }
        case states.FUNCTION: {
            functionState(token);
            break;
          }
        case states.PACKAGE: {
            packageState(token);
            break;
          }
        case states.DECLARATION: {
            declarationState(token);
            break;
          }
      }
      if (!noTokenTypeUpdate) {
        tokenType = currentNode.type;
      }
      noTokenTypeUpdate = false;

      m[0].split("\n").forEach((line, index) => {
        const span = document.createElement("span");
        span.textContent = line; //.replaceAll(/ {2,}/g, "&nbsp;");
        switch (tokenType) {
        case "STRING":
          span.classList.add("string");
          break;
        case "COMMENT":
          span.classList.add("comment");
          break;
        case "BLOCK":
          span.classList.add("block");
          break;
        case "FUNCTION":
          span.classList.add("function");
          break;
        case "PACKAGE":
          span.classList.add("package");
          break;

        }

        if (index !== 0) {
          const br = document.createElement("br");
          page.appendChild(br);
        };

        page.appendChild(span);

    });


    /*const div = document.createElement("div");

      div.style.border = "1px solid";

      div.textContent = "&nbsp;" + "&nbsp;";
      page.appendChild(div);*/
  }
  while (stateStack.length > 0) {
    popStateStack();
  }

  function codeState(token) {
    processBlockScopeToken(token);
  }
  function stringState(token) {
    const {
      delimiter,
      escaped
    } = currentNode;

    switch (token) {
    case delimiter: {
        if (!escaped) {
          popStateStack();
          noTokenTypeUpdate = true;
          return;
        }
        break;
      }
    }
    currentNode.children.push(token);
  }
  function commentState(token) {
    switch (token) {
    case "\n": {
        popStateStack();
        break;
      }
    }
    currentNode.children.push(token);
  }
  function blockState(token) {
    switch (token) {
    case "}": {
        popStateStack();
        noTokenTypeUpdate = true;
        break;
      }
    default: {
        processBlockScopeToken(token);
      }
    }
  }
  function functionState(token) {
    switch (token) {
    case "{": {
        if (currentNode.name) {
          newState("BLOCK");
          return;
        }
        currentNode.name = currentNode.children;
        currentNode.children = [];
        break;
      }
    case "}": {
        popStateStack();
        noTokenTypeUpdate = true;
        break;
      }
    default: {
        processBlockScopeToken(token);
      }
    }
  }
  function packageState(token) {
    if (!currentNode.currentExpression) {
      currentNode.currentExpression = "";
    }
    switch (token) {
    case ";": {
        if (currentNode.currentExpression.trim() === "1") {
          popStateStack();
          return;
        }
        if (!currentNode.name) {
          currentNode.name = currentNode.children;
          currentNode.children = [];
        } else {
          processBlockScopeToken(token);
        }
        currentNode.currentExpression = "";
        break;
      }
    default: {
        const stateChanged = processBlockScopeToken(token);
        if (stateChanged) {
          currentNode.currentExpression = "";
        } else {
          currentNode.currentExpression += token;
        }
      }
    }
  }
  function declarationState(token) {
    if (!currentNode.arguments) currentNode.arguments = [];
    if (currentNode.arguments?.length > 0 && !currentNode.multipleArgs) {
      popStateStack();
      return;
    }
    switch (token) {
    case "(": {
        currentNode.multipleArgs = true;
        break;
      }
    case ")": {
        popStateStack();
        noTokenTypeUpdate = true;
        break;
      }
    default: {
        if ((new RegExp(variableMatcher)).test(token)) {
          currentNode.arguments.push(token);
        } else {
          pushTokenToChildren(token);
        }
      }
    }
  }
  function pushTokenToChildren(token) {
    if (/^\s*$/.test(token)) {
      if (!currentNode.whiteSpaces) currentNode.whiteSpaces = {};
      const length = currentNode.children.length +
      Object.keys(currentNode.whiteSpaces).length;
      currentNode.whiteSpaces[length] = token;
      return;
    }
    currentNode.children.push(token);
  }
  function processBlockScopeToken(token) {
    let stateChanged = true;
    switch (token) {
    case "'":
    case '"':
      newState("STRING");
      currentNode.delimiter = token;
      break;
    case "#":
      newState("COMMENT");
      break;
    case "{":
      newState("BLOCK");
      break;
    case "sub":
      newState("FUNCTION");
      break;
    case "package":
      newState("PACKAGE");
      break;
    case "my":
      newState("DECLARATION");
      break;
    default:
      stateChanged = false;
      pushTokenToChildren(token);
      break;
    }
    return stateChanged;
  }
  function popStateStack() {
    const {
      state,
      node,
    } = stateStack.pop();
    const prevNode = currentNode;
    currentState = state;
    currentNode = node;

    currentNode.children.push(prevNode);
    return prevNode;
  }
  function pushStateStack() {
    stateStack.push({
      state: currentState,
      node: currentNode,
    });
  }
  function newState(stateName) {
    pushStateStack();
    currentState = states[stateName];
    currentNode = {
      children: [],
      type: stateName,
    };
  }
  class AbstractSyntaxTree {
    constructor(node) {
      this.rootNode = node;
    }
    toString() {
      function processChildren(node) {
        return node.children.map(c => traverse(c)).join("");
      }
      function traverse(node) {
        if (typeof node === "string") {
          return node;
        }
        switch (node.type) {
        case "CODE": {
            return processChildren(node);
          }
        case "FUNCTION": {
            const name = node.name.map(n => traverse(n)).join("");
            return `sub ${name}{${processChildren(node)}}`;
          }
        case "PACKAGE": {
            const name = node.name.map(n => traverse(n)).join("");
            const children = processChildren(node.children);
            return `package ${name};${children}1;`;
          }
        case "DECLARATION": {
            const children = processChildren(node.children);
            if (node.arguments.length > 1) {
              return `my ${node.arguments[0]}${children}`;
            }
            const args = node.arguments.map(n => traverse(n)).join("");
            return `my (${args})${children}`;
          }
        case "STRING": {
            break;
          }
        case "COMMENT": {
            break;
          }
        case "BLOCK": {
            break;
          }
        }
      }
    }

  }


  function getObfuscated(token) {
    return token + "_o";
  }
  console.log(currentNode)
</script>

</body>
</html>